// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: room_interface.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 显示玩家信息，qqgameid为玩家的账号，gameCreated时取得。
type ShowUser struct {
	Playerid int64 `protobuf:"varint,1,opt,name=playerid,proto3" json:"playerid,omitempty"`
}

func (m *ShowUser) Reset()                    { *m = ShowUser{} }
func (m *ShowUser) String() string            { return proto.CompactTextString(m) }
func (*ShowUser) ProtoMessage()               {}
func (*ShowUser) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{0} }

func (m *ShowUser) GetPlayerid() int64 {
	if m != nil {
		return m.Playerid
	}
	return 0
}

type ShowUserRet struct {
	Player *Player `protobuf:"bytes,1,opt,name=player" json:"player,omitempty"`
}

func (m *ShowUserRet) Reset()                    { *m = ShowUserRet{} }
func (m *ShowUserRet) String() string            { return proto.CompactTextString(m) }
func (*ShowUserRet) ProtoMessage()               {}
func (*ShowUserRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{1} }

func (m *ShowUserRet) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

type JoinRoom struct {
	AppID  string `protobuf:"bytes,1,opt,name=appID,proto3" json:"appID,omitempty"`
	RoomID string `protobuf:"bytes,2,opt,name=roomID,proto3" json:"roomID,omitempty"`
}

func (m *JoinRoom) Reset()                    { *m = JoinRoom{} }
func (m *JoinRoom) String() string            { return proto.CompactTextString(m) }
func (*JoinRoom) ProtoMessage()               {}
func (*JoinRoom) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{2} }

func (m *JoinRoom) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *JoinRoom) GetRoomID() string {
	if m != nil {
		return m.RoomID
	}
	return ""
}

// 玩家加入房间信息
type JoinRoomRet struct {
	RoomID  string    `protobuf:"bytes,1,opt,name=roomID,proto3" json:"roomID,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *JoinRoomRet) Reset()                    { *m = JoinRoomRet{} }
func (m *JoinRoomRet) String() string            { return proto.CompactTextString(m) }
func (*JoinRoomRet) ProtoMessage()               {}
func (*JoinRoomRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{3} }

func (m *JoinRoomRet) GetRoomID() string {
	if m != nil {
		return m.RoomID
	}
	return ""
}

func (m *JoinRoomRet) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

type GetRoomInfo struct {
	AppID  string `protobuf:"bytes,1,opt,name=appID,proto3" json:"appID,omitempty"`
	RoomID string `protobuf:"bytes,2,opt,name=roomID,proto3" json:"roomID,omitempty"`
}

func (m *GetRoomInfo) Reset()                    { *m = GetRoomInfo{} }
func (m *GetRoomInfo) String() string            { return proto.CompactTextString(m) }
func (*GetRoomInfo) ProtoMessage()               {}
func (*GetRoomInfo) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{4} }

func (m *GetRoomInfo) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *GetRoomInfo) GetRoomID() string {
	if m != nil {
		return m.RoomID
	}
	return ""
}

type GetRoomInfoRet struct {
	RoomID  string    `protobuf:"bytes,1,opt,name=roomID,proto3" json:"roomID,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *GetRoomInfoRet) Reset()                    { *m = GetRoomInfoRet{} }
func (m *GetRoomInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetRoomInfoRet) ProtoMessage()               {}
func (*GetRoomInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{5} }

func (m *GetRoomInfoRet) GetRoomID() string {
	if m != nil {
		return m.RoomID
	}
	return ""
}

func (m *GetRoomInfoRet) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 创建房间 匹配成功后内部调用
type RoomCreate struct {
	AppID   string    `protobuf:"bytes,1,opt,name=appID,proto3" json:"appID,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *RoomCreate) Reset()                    { *m = RoomCreate{} }
func (m *RoomCreate) String() string            { return proto.CompactTextString(m) }
func (*RoomCreate) ProtoMessage()               {}
func (*RoomCreate) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{6} }

func (m *RoomCreate) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *RoomCreate) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 发送游戏数据, data参数结构由游戏自拟，接收方收到的data与发送方发送的结构和内容一致。
// 1v1游戏中，玩家A调用invoke gameData发送消息，玩家B使用onMessage gameData接收消息。
// 但在2v2游戏中，有A、B、C、D四个玩家，A调用invoke gameData发送消息时，玩家B、C、D都可以收到，
// 但是B、C、D并不知道消息的发送方为哪位玩家，所以在2v2游戏中调用invoke gameData发送消息时，需显示声明发送者的身份。
type GameData struct {
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *GameData) Reset()                    { *m = GameData{} }
func (m *GameData) String() string            { return proto.CompactTextString(m) }
func (*GameData) ProtoMessage()               {}
func (*GameData) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{7} }

func (m *GameData) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type GameReady struct {
}

func (m *GameReady) Reset()                    { *m = GameReady{} }
func (m *GameReady) String() string            { return proto.CompactTextString(m) }
func (*GameReady) ProtoMessage()               {}
func (*GameReady) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{8} }

// 上报帧数据
type FrameData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *FrameData) Reset()                    { *m = FrameData{} }
func (m *FrameData) String() string            { return proto.CompactTextString(m) }
func (*FrameData) ProtoMessage()               {}
func (*FrameData) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{9} }

func (m *FrameData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 上报游戏结果
type UploadGameResult struct {
	Detail []*PlayerResult `protobuf:"bytes,1,rep,name=detail" json:"detail,omitempty"`
}

func (m *UploadGameResult) Reset()                    { *m = UploadGameResult{} }
func (m *UploadGameResult) String() string            { return proto.CompactTextString(m) }
func (*UploadGameResult) ProtoMessage()               {}
func (*UploadGameResult) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{10} }

func (m *UploadGameResult) GetDetail() []*PlayerResult {
	if m != nil {
		return m.Detail
	}
	return nil
}

type UploadGameResultRet struct {
	Result int32 `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *UploadGameResultRet) Reset()         { *m = UploadGameResultRet{} }
func (m *UploadGameResultRet) String() string { return proto.CompactTextString(m) }
func (*UploadGameResultRet) ProtoMessage()    {}
func (*UploadGameResultRet) Descriptor() ([]byte, []int) {
	return fileDescriptorRoomInterface, []int{11}
}

func (m *UploadGameResultRet) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 再来一局
type OnceMore struct {
}

func (m *OnceMore) Reset()                    { *m = OnceMore{} }
func (m *OnceMore) String() string            { return proto.CompactTextString(m) }
func (*OnceMore) ProtoMessage()               {}
func (*OnceMore) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{12} }

//
type OnceMoreRet struct {
}

func (m *OnceMoreRet) Reset()                    { *m = OnceMoreRet{} }
func (m *OnceMoreRet) String() string            { return proto.CompactTextString(m) }
func (*OnceMoreRet) ProtoMessage()               {}
func (*OnceMoreRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{13} }

// 大厅收到游戏gameInit，开始匹配对手玩家，并建立双方玩家通信通道，完成后通过channelCreated将双方玩家信息发送给游戏，玩家信息格式如下：
type RoomCreatedRet struct {
	Players []*Player `protobuf:"bytes,1,rep,name=players" json:"players,omitempty"`
}

func (m *RoomCreatedRet) Reset()                    { *m = RoomCreatedRet{} }
func (m *RoomCreatedRet) String() string            { return proto.CompactTextString(m) }
func (*RoomCreatedRet) ProtoMessage()               {}
func (*RoomCreatedRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{14} }

func (m *RoomCreatedRet) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 玩家离开房间推送
type PlayerLeaveRet struct {
	PlayerID int32 `protobuf:"varint,1,opt,name=playerID,proto3" json:"playerID,omitempty"`
}

func (m *PlayerLeaveRet) Reset()                    { *m = PlayerLeaveRet{} }
func (m *PlayerLeaveRet) String() string            { return proto.CompactTextString(m) }
func (*PlayerLeaveRet) ProtoMessage()               {}
func (*PlayerLeaveRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{15} }

func (m *PlayerLeaveRet) GetPlayerID() int32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

// 玩家加入房间推送
type PlayerJoinRet struct {
	RoomID string  `protobuf:"bytes,1,opt,name=roomID,proto3" json:"roomID,omitempty"`
	Player *Player `protobuf:"bytes,2,opt,name=player" json:"player,omitempty"`
}

func (m *PlayerJoinRet) Reset()                    { *m = PlayerJoinRet{} }
func (m *PlayerJoinRet) String() string            { return proto.CompactTextString(m) }
func (*PlayerJoinRet) ProtoMessage()               {}
func (*PlayerJoinRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{16} }

func (m *PlayerJoinRet) GetRoomID() string {
	if m != nil {
		return m.RoomID
	}
	return ""
}

func (m *PlayerJoinRet) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

// 收到所有玩家gameReady，大厅通知游戏开始。
type GameStartRet struct {
}

func (m *GameStartRet) Reset()                    { *m = GameStartRet{} }
func (m *GameStartRet) String() string            { return proto.CompactTextString(m) }
func (*GameStartRet) ProtoMessage()               {}
func (*GameStartRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{17} }

// 接收其他玩家发送的data，接收到的数据与发送的数据结构和内容一致。
// 比如，玩家A通过invoke gameData发送数据{x:1, y: 2}，玩家B通过onMessage gameData收到的数据也为{x:1, y: 2}。
type GameDataRet struct {
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *GameDataRet) Reset()                    { *m = GameDataRet{} }
func (m *GameDataRet) String() string            { return proto.CompactTextString(m) }
func (*GameDataRet) ProtoMessage()               {}
func (*GameDataRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{18} }

func (m *GameDataRet) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 帧同步游戏接收帧数据
type FrameDataRet struct {
	Index int32  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Data  string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *FrameDataRet) Reset()                    { *m = FrameDataRet{} }
func (m *FrameDataRet) String() string            { return proto.CompactTextString(m) }
func (*FrameDataRet) ProtoMessage()               {}
func (*FrameDataRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{19} }

func (m *FrameDataRet) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *FrameDataRet) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 玩家离开游戏 或房间
type LeaveRet struct {
	Playerid int64 `protobuf:"varint,1,opt,name=playerid,proto3" json:"playerid,omitempty"`
}

func (m *LeaveRet) Reset()                    { *m = LeaveRet{} }
func (m *LeaveRet) String() string            { return proto.CompactTextString(m) }
func (*LeaveRet) ProtoMessage()               {}
func (*LeaveRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{20} }

func (m *LeaveRet) GetPlayerid() int64 {
	if m != nil {
		return m.Playerid
	}
	return 0
}

// 玩家断开网络
type NetworkRet struct {
	Playerid int64 `protobuf:"varint,1,opt,name=playerid,proto3" json:"playerid,omitempty"`
	Online   bool  `protobuf:"varint,2,opt,name=online,proto3" json:"online,omitempty"`
}

func (m *NetworkRet) Reset()                    { *m = NetworkRet{} }
func (m *NetworkRet) String() string            { return proto.CompactTextString(m) }
func (*NetworkRet) ProtoMessage()               {}
func (*NetworkRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{21} }

func (m *NetworkRet) GetPlayerid() int64 {
	if m != nil {
		return m.Playerid
	}
	return 0
}

func (m *NetworkRet) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

// 玩家音频信息
type VoiceRet struct {
	Playerid int64 `protobuf:"varint,1,opt,name=playerid,proto3" json:"playerid,omitempty"`
	Open     bool  `protobuf:"varint,2,opt,name=open,proto3" json:"open,omitempty"`
	Talking  bool  `protobuf:"varint,3,opt,name=talking,proto3" json:"talking,omitempty"`
}

func (m *VoiceRet) Reset()                    { *m = VoiceRet{} }
func (m *VoiceRet) String() string            { return proto.CompactTextString(m) }
func (*VoiceRet) ProtoMessage()               {}
func (*VoiceRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{22} }

func (m *VoiceRet) GetPlayerid() int64 {
	if m != nil {
		return m.Playerid
	}
	return 0
}

func (m *VoiceRet) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

func (m *VoiceRet) GetTalking() bool {
	if m != nil {
		return m.Talking
	}
	return false
}

// 大厅通知游戏重置，此时游戏需重置到初始状态（不能通过刷新页面实现），并再次调用gameInit
type GameResetRet struct {
}

func (m *GameResetRet) Reset()                    { *m = GameResetRet{} }
func (m *GameResetRet) String() string            { return proto.CompactTextString(m) }
func (*GameResetRet) ProtoMessage()               {}
func (*GameResetRet) Descriptor() ([]byte, []int) { return fileDescriptorRoomInterface, []int{23} }

func init() {
	proto.RegisterType((*ShowUser)(nil), "protocol.showUser")
	proto.RegisterType((*ShowUserRet)(nil), "protocol.showUserRet")
	proto.RegisterType((*JoinRoom)(nil), "protocol.joinRoom")
	proto.RegisterType((*JoinRoomRet)(nil), "protocol.joinRoomRet")
	proto.RegisterType((*GetRoomInfo)(nil), "protocol.getRoomInfo")
	proto.RegisterType((*GetRoomInfoRet)(nil), "protocol.getRoomInfoRet")
	proto.RegisterType((*RoomCreate)(nil), "protocol.roomCreate")
	proto.RegisterType((*GameData)(nil), "protocol.gameData")
	proto.RegisterType((*GameReady)(nil), "protocol.gameReady")
	proto.RegisterType((*FrameData)(nil), "protocol.frameData")
	proto.RegisterType((*UploadGameResult)(nil), "protocol.uploadGameResult")
	proto.RegisterType((*UploadGameResultRet)(nil), "protocol.uploadGameResultRet")
	proto.RegisterType((*OnceMore)(nil), "protocol.onceMore")
	proto.RegisterType((*OnceMoreRet)(nil), "protocol.onceMoreRet")
	proto.RegisterType((*RoomCreatedRet)(nil), "protocol.roomCreatedRet")
	proto.RegisterType((*PlayerLeaveRet)(nil), "protocol.playerLeaveRet")
	proto.RegisterType((*PlayerJoinRet)(nil), "protocol.playerJoinRet")
	proto.RegisterType((*GameStartRet)(nil), "protocol.gameStartRet")
	proto.RegisterType((*GameDataRet)(nil), "protocol.gameDataRet")
	proto.RegisterType((*FrameDataRet)(nil), "protocol.frameDataRet")
	proto.RegisterType((*LeaveRet)(nil), "protocol.leaveRet")
	proto.RegisterType((*NetworkRet)(nil), "protocol.networkRet")
	proto.RegisterType((*VoiceRet)(nil), "protocol.voiceRet")
	proto.RegisterType((*GameResetRet)(nil), "protocol.gameResetRet")
}
func (m *ShowUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Playerid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Playerid))
	}
	return i, nil
}

func (m *ShowUserRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowUserRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Player.Size()))
		n1, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *JoinRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.RoomID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.RoomID)))
		i += copy(dAtA[i:], m.RoomID)
	}
	return i, nil
}

func (m *JoinRoomRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinRoomRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.RoomID)))
		i += copy(dAtA[i:], m.RoomID)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRoomInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetRoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.RoomID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.RoomID)))
		i += copy(dAtA[i:], m.RoomID)
	}
	return i, nil
}

func (m *GetRoomInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoomInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.RoomID)))
		i += copy(dAtA[i:], m.RoomID)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRoomInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoomCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRoomInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GameData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *GameReady) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameReady) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FrameData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *UploadGameResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadGameResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Detail) > 0 {
		for _, msg := range m.Detail {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoomInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UploadGameResultRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadGameResultRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *OnceMore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnceMore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *OnceMoreRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnceMoreRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RoomCreatedRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreatedRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoomInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PlayerLeaveRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerLeaveRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.PlayerID))
	}
	return i, nil
}

func (m *PlayerJoinRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerJoinRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.RoomID)))
		i += copy(dAtA[i:], m.RoomID)
	}
	if m.Player != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Player.Size()))
		n2, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GameStartRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GameDataRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameDataRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *FrameDataRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameDataRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Index))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *LeaveRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Playerid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Playerid))
	}
	return i, nil
}

func (m *NetworkRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Playerid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Playerid))
	}
	if m.Online {
		dAtA[i] = 0x10
		i++
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *VoiceRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoiceRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Playerid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoomInterface(dAtA, i, uint64(m.Playerid))
	}
	if m.Open {
		dAtA[i] = 0x10
		i++
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Talking {
		dAtA[i] = 0x18
		i++
		if m.Talking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GameResetRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameResetRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintRoomInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ShowUser) Size() (n int) {
	var l int
	_ = l
	if m.Playerid != 0 {
		n += 1 + sovRoomInterface(uint64(m.Playerid))
	}
	return n
}

func (m *ShowUserRet) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *JoinRoom) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *JoinRoomRet) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoomInterface(uint64(l))
		}
	}
	return n
}

func (m *GetRoomInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *GetRoomInfoRet) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoomInterface(uint64(l))
		}
	}
	return n
}

func (m *RoomCreate) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoomInterface(uint64(l))
		}
	}
	return n
}

func (m *GameData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *GameReady) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FrameData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *UploadGameResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Detail) > 0 {
		for _, e := range m.Detail {
			l = e.Size()
			n += 1 + l + sovRoomInterface(uint64(l))
		}
	}
	return n
}

func (m *UploadGameResultRet) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovRoomInterface(uint64(m.Result))
	}
	return n
}

func (m *OnceMore) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *OnceMoreRet) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RoomCreatedRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovRoomInterface(uint64(l))
		}
	}
	return n
}

func (m *PlayerLeaveRet) Size() (n int) {
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovRoomInterface(uint64(m.PlayerID))
	}
	return n
}

func (m *PlayerJoinRet) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *GameStartRet) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GameDataRet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *FrameDataRet) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRoomInterface(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRoomInterface(uint64(l))
	}
	return n
}

func (m *LeaveRet) Size() (n int) {
	var l int
	_ = l
	if m.Playerid != 0 {
		n += 1 + sovRoomInterface(uint64(m.Playerid))
	}
	return n
}

func (m *NetworkRet) Size() (n int) {
	var l int
	_ = l
	if m.Playerid != 0 {
		n += 1 + sovRoomInterface(uint64(m.Playerid))
	}
	if m.Online {
		n += 2
	}
	return n
}

func (m *VoiceRet) Size() (n int) {
	var l int
	_ = l
	if m.Playerid != 0 {
		n += 1 + sovRoomInterface(uint64(m.Playerid))
	}
	if m.Open {
		n += 2
	}
	if m.Talking {
		n += 2
	}
	return n
}

func (m *GameResetRet) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovRoomInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoomInterface(x uint64) (n int) {
	return sovRoomInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShowUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: showUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: showUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playerid", wireType)
			}
			m.Playerid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Playerid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowUserRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: showUserRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: showUserRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: joinRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: joinRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinRoomRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: joinRoomRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: joinRoomRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getRoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getRoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoomInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getRoomInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getRoomInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: roomCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: roomCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gameData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gameData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameReady) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gameReady: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gameReady: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: frameData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: frameData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadGameResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: uploadGameResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: uploadGameResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = append(m.Detail, &PlayerResult{})
			if err := m.Detail[len(m.Detail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadGameResultRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: uploadGameResultRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: uploadGameResultRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnceMore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: onceMore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: onceMore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnceMoreRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: onceMoreRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: onceMoreRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreatedRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: roomCreatedRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: roomCreatedRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerLeaveRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playerLeaveRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playerLeaveRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerJoinRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playerJoinRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playerJoinRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gameStartRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gameStartRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameDataRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gameDataRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gameDataRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameDataRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: frameDataRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: frameDataRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoomInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: leaveRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: leaveRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playerid", wireType)
			}
			m.Playerid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Playerid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: networkRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: networkRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playerid", wireType)
			}
			m.Playerid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Playerid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoiceRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: voiceRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: voiceRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playerid", wireType)
			}
			m.Playerid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Playerid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Talking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameResetRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gameResetRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gameResetRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoomInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoomInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoomInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoomInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoomInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoomInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoomInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoomInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoomInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoomInterface   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("room_interface.proto", fileDescriptorRoomInterface) }

var fileDescriptorRoomInterface = []byte{
	// 512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xc1, 0x6e, 0x13, 0x31,
	0x10, 0xd5, 0x26, 0x24, 0xdd, 0xcc, 0xa6, 0x51, 0x64, 0xa2, 0x6a, 0xd5, 0x43, 0x28, 0x3e, 0x54,
	0x15, 0x82, 0x1c, 0xe0, 0x40, 0x25, 0x38, 0xa0, 0x12, 0x09, 0x05, 0x01, 0xa2, 0xa6, 0x9c, 0x91,
	0xc9, 0x4e, 0xc2, 0xd2, 0x8d, 0x67, 0xe5, 0xb8, 0x2d, 0xfd, 0x43, 0x8e, 0x7c, 0x02, 0xca, 0x97,
	0x20, 0x7b, 0xed, 0x24, 0xa2, 0x81, 0xa8, 0x52, 0x4f, 0x99, 0xe7, 0x79, 0x6f, 0xe6, 0xe5, 0x79,
	0x0d, 0x3d, 0x4d, 0x34, 0xfb, 0x92, 0x2b, 0x83, 0x7a, 0x22, 0xc7, 0x38, 0x28, 0x35, 0x19, 0x62,
	0xb1, 0xfb, 0x19, 0x53, 0xb1, 0xdf, 0x75, 0xfd, 0x19, 0x65, 0x58, 0x54, 0x3d, 0x7e, 0x08, 0xf1,
	0xfc, 0x1b, 0x5d, 0x7d, 0x9e, 0xa3, 0x66, 0xfb, 0x10, 0x97, 0x85, 0xbc, 0x46, 0x9d, 0x67, 0x69,
	0x74, 0x10, 0x1d, 0xd5, 0xc5, 0x12, 0xf3, 0xe7, 0x90, 0x04, 0x9e, 0x40, 0xc3, 0x8e, 0xa0, 0x59,
	0xb5, 0x1c, 0x31, 0x79, 0xda, 0x1d, 0x84, 0x1d, 0x83, 0x8f, 0xee, 0x5c, 0xf8, 0x3e, 0x3f, 0x86,
	0xf8, 0x3b, 0xe5, 0x4a, 0x10, 0xcd, 0x58, 0x0f, 0x1a, 0xb2, 0x2c, 0x47, 0x43, 0x27, 0x6a, 0x89,
	0x0a, 0xb0, 0x3d, 0x68, 0x5a, 0x5b, 0xa3, 0x61, 0x5a, 0x73, 0xc7, 0x1e, 0xf1, 0x53, 0x48, 0x82,
	0xd2, 0xae, 0x5c, 0xd1, 0xa2, 0x75, 0x1a, 0x7b, 0x04, 0x3b, 0xd5, 0xaa, 0x79, 0x5a, 0x3b, 0xa8,
	0x6f, 0xf4, 0x12, 0x08, 0xfc, 0x05, 0x24, 0x53, 0x34, 0x76, 0xe2, 0x48, 0x4d, 0xe8, 0x96, 0x7e,
	0xce, 0xa0, 0xb3, 0x26, 0xbe, 0x2b, 0x4b, 0x1f, 0x00, 0xac, 0xea, 0xb5, 0x46, 0x69, 0xf0, 0x1f,
	0x8e, 0x6e, 0x33, 0xaf, 0x0f, 0xf1, 0x54, 0xce, 0x70, 0x28, 0x8d, 0x64, 0x0c, 0xee, 0x65, 0xd2,
	0x48, 0x3f, 0xcc, 0xd5, 0x3c, 0x81, 0x96, 0xed, 0x0b, 0x94, 0xd9, 0x35, 0x7f, 0x00, 0xad, 0x89,
	0xde, 0xc4, 0x6e, 0x7b, 0xf6, 0x09, 0x74, 0x2f, 0xca, 0x82, 0x64, 0xf6, 0xc6, 0x69, 0xe6, 0x17,
	0x85, 0x61, 0x03, 0x68, 0x66, 0x68, 0x64, 0x5e, 0xa4, 0x91, 0x33, 0xb3, 0x77, 0xc3, 0x8c, 0xe3,
	0x09, 0xcf, 0xe2, 0x4f, 0xe0, 0xfe, 0xdf, 0x33, 0x42, 0x78, 0x0e, 0xb8, 0x85, 0x0d, 0xe1, 0x11,
	0x07, 0x88, 0x49, 0x8d, 0xf1, 0x3d, 0x69, 0xe4, 0xbb, 0x90, 0x84, 0x5a, 0xa0, 0xe1, 0x2f, 0xa1,
	0xb3, 0xca, 0x2a, 0xb3, 0x43, 0xd6, 0x92, 0x89, 0xb6, 0x25, 0xf3, 0x18, 0x3a, 0x55, 0xf9, 0x0e,
	0xe5, 0xa5, 0x9d, 0xb7, 0xfa, 0xe0, 0x7d, 0xe0, 0x0d, 0xb1, 0xc4, 0xfc, 0x14, 0x76, 0xab, 0xfa,
	0xad, 0xfd, 0x06, 0xff, 0x73, 0xd9, 0xab, 0xa7, 0x50, 0xdb, 0xf2, 0x14, 0x3a, 0xd0, 0xb6, 0xd1,
	0x7f, 0x32, 0x52, 0xdb, 0x04, 0xf8, 0x43, 0x48, 0xc2, 0x55, 0xd9, 0x05, 0x9b, 0x6e, 0xeb, 0x18,
	0xda, 0xcb, 0x0b, 0xb2, 0x9c, 0x1e, 0x34, 0x72, 0x95, 0xe1, 0x0f, 0x6f, 0xb7, 0x02, 0x4b, 0x65,
	0x6d, 0x4d, 0x79, 0x08, 0x71, 0x71, 0xe3, 0x7f, 0x6e, 0x78, 0xd8, 0xaf, 0x00, 0x14, 0x9a, 0x2b,
	0xd2, 0xe7, 0x5b, 0x98, 0x36, 0x00, 0x52, 0x45, 0xae, 0xd0, 0xed, 0x89, 0x85, 0x47, 0xfc, 0x0c,
	0xe2, 0x4b, 0xca, 0xc7, 0xdb, 0x36, 0x59, 0x97, 0x54, 0xa2, 0xf2, 0x6a, 0x57, 0xb3, 0x14, 0x76,
	0x8c, 0x2c, 0xce, 0x73, 0x35, 0x4d, 0xeb, 0xee, 0x38, 0xc0, 0x10, 0x96, 0xc0, 0x39, 0xda, 0xb0,
	0x4e, 0xda, 0x3f, 0x17, 0xfd, 0xe8, 0xd7, 0xa2, 0x1f, 0xfd, 0x5e, 0xf4, 0xa3, 0xaf, 0x4d, 0x97,
	0xf1, 0xb3, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd7, 0xef, 0x1a, 0x96, 0xf1, 0x04, 0x00, 0x00,
}
